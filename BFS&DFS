import java.util.Scanner;

class GraphTraversal {
    static final int MAX = 10;

    static class Stack {
        int[] data = new int[MAX];
        int top = -1;

        void push(int x) {
            data[++top] = x;
        }

        int pop() {
            return data[top--];
        }

        boolean isEmpty() {
            return top == -1;
        }
    }

    static class Queue {
        int[] data = new int[MAX];
        int front = 0, rear = 0;

        void enqueue(int x) {
            data[rear++] = x;
        }

        int dequeue() {
            return data[front++];
        }

        boolean isEmpty() {
            return front == rear;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = 4; // Locations: A, B, C, D

        // Adjacency Matrix
        int[][] graph = {
            {0, 1, 1, 0}, // A connected to B, C
            {1, 0, 0, 1}, // B connected to A, D
            {1, 0, 0, 1}, // C connected to A, D
            {0, 1, 1, 0}  // D connected to B, C
        };

        while (true) {
            System.out.println("\n===== MENU =====");
            System.out.println("1. DFS (Adjacency Matrix)");
            System.out.println("2. BFS (Adjacency List)");
            System.out.println("3. Exit");
            System.out.print("Enter your choice: ");
            int choice = sc.nextInt();

            switch (choice) {
                case 1:
                    System.out.println("DFS Traversal:");
                    dfs(graph, n);
                    break;

                case 2:
                    System.out.println("BFS Traversal:");
                    bfs(graph, n);
                    break;

                case 3:
                    System.out.println("Exiting...");
                    sc.close();
                    return;

                default:
                    System.out.println("Invalid choice! Try again.");
            }
        }
    }

    // DFS using Stack (Adjacency Matrix)
    static void dfs(int[][] g, int n) {
        int[] visited = new int[n];
        Stack s = new Stack();
        s.push(0); // Start from A
        visited[0] = 1;

        while (!s.isEmpty()) {
            int node = s.pop();
            System.out.print((char) (node + 'A') + " ");

            for (int i = n - 1; i >= 0; i--) {
                if (g[node][i] == 1 && visited[i] == 0) {
                    s.push(i);
                    visited[i] = 1;
                }
            }
        }
        System.out.println();
    }

    // BFS using Queue (Adjacency List)
    static void bfs(int[][] g, int n) {
        int[] visited = new int[n];
        Queue q = new Queue();
        q.enqueue(0); // Start from A
        visited[0] = 1;

        while (!q.isEmpty()) {
            int node = q.dequeue();
            System.out.print((char) (node + 'A') + " ");

            for (int i = 0; i < n; i++) {
                if (g[node][i] == 1 && visited[i] == 0) {
                    q.enqueue(i);
                    visited[i] = 1;
                }
            }
        }
        System.out.println();
    }
}
